library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.NUMERIC_STD.all;
use work.npath_package.all;


entity fir_basic is 
	generic ( 
		n	: natural  := 4;
		width	: natural  := 8
	);
	port (
		clk  	: in  std_logic;
		vin	: in  std_logic_vector(width-1 downto 0); 
		vout	: out std_logic_vector(width-1 downto 0);
		vout_t, vout_s  : out bits_array_t(n - 1 downto 0) := (others => (others => '0'))
	);
end fir_basic;

architecture behavior of fir_basic is

signal  q_s : bits_array_t(n - 1 downto 0) := (others => (others => '0'));
signal q_sum :  std_logic_vector(width-1 downto 0) := (others => '0');
type sum_int is array (n - 1 downto 0) of real;
signal sum_vec  : sum_int := (others => 0.0);

component reg is
	generic ( 
		width	: natural  := 8
	);
	port (
		clk  	: in  std_logic;
		d    	: in  std_logic_vector(width-1 downto 0)  := (others => '0');
		q	: out std_logic_vector(width-1 downto 0)  := (others => '0')
	);
end component; 

begin
	
	sum_vec(n-1) <= real(to_integer(unsigned(vin)))*my_rom(n-1);
	reg_fir_n: reg generic map ( width => width ) port map ( clk => clk, d => vin, q => q_s(n-1) );
	out_assig: for i in n-2 downto 0 generate
		reg_fir: reg generic map ( width => width ) port map ( clk => clk, d => q_s(i+1), q => q_s(i) );	
		sum_vec(i) <= real(to_integer(unsigned(q_s(i + 1))))*my_rom(i) + sum_vec(i+1); 
	end generate;	

	vout_t <= q_s; 
	q_sum <= std_logic_vector(to_unsigned(integer(sum_vec(0)), width));
	reg_out: reg generic map ( width => width ) port map ( clk => clk, d => q_sum, q => vout );

	vout_s(0) <= std_logic_vector(to_unsigned(integer(real(to_integer(unsigned(q_s(1))))*my_rom(0)), width));
	vout_s(1) <= std_logic_vector(to_unsigned(integer(real(to_integer(unsigned(q_s(2))))*my_rom(1)), width));
	vout_s(2) <= std_logic_vector(to_unsigned(integer(real(to_integer(unsigned(q_s(3))))*my_rom(2)), width));
	vout_s(3) <= std_logic_vector(to_unsigned(integer(real(to_integer(unsigned(vin)))*my_rom(3)), width));
 
end behavior;